<html>
    <head>
        <title>Lesson10.Vuex的Module(二)</title>
        <script src="https://cdn.jsdelivr.net/npm/es6-promise@4/dist/es6-promise.auto.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
        <script src="https://unpkg.com/vuex@3.0.1/dist/vuex.js"></script>
    </head>
    <body>
        <script>
             const moduleA = {
               state:{
                  count: 0,
               },
                  //对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象，因此这里改变的是count: 0
               mutations:{
                   increment(state){
                       state.count++;
                   }
               },
               //对于模块内部的 getter，根节点状态会作为第三个参数暴露出来
               getters:{
                   doubleCount(state){
                       return state.count*2
                   },
                   sumWithRootCount(state,getters,rootState){
                       return state.count+rootState.count
                   }
               },
               actions:{
                   //对于模块内部的 action，局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState
                   //按照现在代码state代表moduleA，rootState代表下面的store,那么state.count就属于局部状态了
                   incrementIfOddOnRooSum({ state,rootState,commit}){
                        console.log("进入前两数值"+state.count+"-"+rootState.count);
                       //这里是moduleA的count+store的count的和是奇数，那么moduleA.count会+1；
                       if( (state.count + rootState.count)%2 ===1 ){
                            commit("increment");
                       }
                       console.log("进入前两数值"+state.count+"-"+rootState.count);
                   }
               }
            }
           const store = new Vuex.Store({
               state:{
                    count:1,
               },
                modules:{
                    a:moduleA,
                }
            })
        </script>
    </body>
</html>